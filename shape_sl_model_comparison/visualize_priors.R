
library(polynom)
library(MCMCpack)
library(jsonlite)
library(ggplot2)
library(gridExtra)

source('DBDA2E-utilities.R')


# A function to put the prior in the form prior = c(fn, params, title) where fn is the type of distribution, params is a vector containing the parameters of that distribution, 
# and title indicates the type of parameter the prior is for (e.g., intercept, slope).

prior.1<-list('intercept' = list(fn = 'gamma', par1 =800, par2 =200 ),
              'proportion' = list(fn =  'gamma', par1 =1, par2 = .5),
              'base' = list(fn = 'unif', par1 =0, par2=1),
              'rate' = list(fn = 'gamma', par1= .3,par2 =.1),
              'sigma' = list(fn = 'inv_gamma', par1=25, par2=5),
              'jump' = list(fn = 'exp', par1=20, par2=1),
              'split' = list(fn = 'unif', par1=0, par2=72) )

write_json(prior.1,'prior.1.json')
library(gridExtra)


extract.prior<-function(priors){
  
  prior<-list()
  i=0
  
  for(param in names(priors)){
    i=i+1
    
    if(param == 'intercept'){
      fn <- priors$intercept$fn[[1]]
      params<- c(as.numeric(priors$intercept$par1), as.numeric(priors$intercept$par2))
      prior[[i]]<-c(fn,params,'Intercept Prior')  
    }
    if(param == 'proportion'){
      fn <- priors$proportion$fn[[1]]
      params<- c(as.numeric(priors$proportion$par1), as.numeric(priors$proportion$par2))
      prior[[i]]<-c(fn, params,'Proprotion Prior')    
    }
    if(param == 'base'){
      fn <- priors$base$fn[[1]]
      params<- c(as.numeric(priors$base$par1), as.numeric(priors$base$par2))
      prior[[i]]<-c(fn,params, 'Base Prior')  
    }
    if(param == 'rate'){
      fn <- priors$rate$fn[[1]]
      params<- c(as.numeric(priors$rate$par1), as.numeric(priors$rate$par2))
      prior[[i]]<-c(fn,params, 'Rate Prior')  
    }
    if(param == 'sigma'){
      fn <- priors$sigma$fn[[1]]
      params<- c(as.numeric(priors$sigma$par1), as.numeric(priors$sigma$par2))
      prior[[i]]<-c(fn, params,'Sigma Prior')    
    }
    if(param == 'jump'){
      fn <- priors$jump$fn[[1]]
      params<- c(as.numeric(priors$jump$par1), as.numeric(priors$jump$par2))
      prior[[i]]<-c(fn, params,'Jump Proprotion Prior')    
    }
    if(param == 'split'){
      fn <- priors$split$fn[[1]]
      params<- c(as.numeric(priors$split$par1), as.numeric(priors$split$par2))
      prior[[i]]<-c(fn, params,'Split Prior')    
    }
    
  }
  return(prior)
}

# A function to compute the range on which to define all graphs for a single prior type on. This is necissary 


# function parameters:
#   list: a list of json files of prior distributions generated by the .

from.to<-function(list,n.params){
  n.priors<-length(list)
  
  
  
  from<-array(dim=c(n.priors,n.params))
  to<-array(dim=c(n.priors,n.params))
  out<-data.frame(from=numeric(length=n.params),to=numeric(length=n.params))
  
  if(n.priors != 1){
    
    for(i in 1:n.priors){
      prior<-read_json(list[[i]])
      prior<-extract.prior(prior)
      
      for(j in 1:n.params){
        pr<-prior[[j]]
        
        fn<-pr[1]
        par1<-as.numeric(pr[2])
        par2<-as.numeric(pr[3])
        
        
        
        if(fn == 'normal'){
          from[i,j]= par1-2.5*par2
          to[i,j]= par1 + 2.5*par2
          
        }
        if(fn == 'gamma'){
          from[i,j] = max(0 , par1 - 3*par2)
          to[i,j] = par1 + 3*par2
        }
        if(fn == 'inv_gamma'){
          
          
          from[i,j] = max(0 , par1 - 3*par2)
          to[i,j] =  par1 + 30*par2
        }
        if(fn== 'beta'){
          from[i,j] = 0
          to[i,j] = 1
        }
        if(fn == 'unif'){
          from[i,j] = par1
          to[i,j] = par2
        }
        if(fn == 'exp'){
          from[i,j] = 0
          to[i,j] = par1*3
        }
        
      }
      out$from[j]<- min(from[,j])
      out$to[j]<-max(to[,j])
    }
  }
  else{
    
    prior<-read_json(list[[1]])
    
    prior<-extract.prior(prior)
    
    
    for(j in 1:n.params){
      
      pr<-prior[[j]]
      
      fn<-pr[1]
      par1<-as.numeric(pr[2])
      par2<-as.numeric(pr[3])
      
      
      
      if(fn == 'normal'){
        out$from[j]= par1-2.5*par2
        out$to[j]= par1 + 2.5*par2
        
      }
      if(fn == 'gamma'){
        out$from[j] = max(0,par1-3*par2)
        out$to[j] = par1 + 3*par2
      }
      if(fn == 'inv_gamma'){
        out$from[j] = max(0 , par1 - .5*par2)
        out$to[j] = par1 + .5*par2
      }
      if(fn== 'beta'){
        out$from[j] = 0
        out$to[j] = 1
      }
      if(fn == 'unif'){
        out$from[j] = par1
        out$to[j] = par2
      }
      if(fn == 'exp'){
        out$from[j] = 0
        out$to[j] = (1/par1)*3
      }
      
    }
  }
  return(out)
}


plot.prior<-function(prior,from,to){
  
  fn<-prior[1]
  par1<-as.numeric(prior[2])
  par2<-as.numeric(prior[3])
  title<-prior[4]
  
  by<-(to-from)/1000
  x<-seq(from,to,by)
  
  
  if(fn == 'normal'){
    
    y<- sapply(x, function(x){return(dnorm(x,par1,par2))}) 
    
    title.2<- paste('Normal(',toString(round(par1,2)),',',toString(round(par2,2)), ')',sep="")
  }
  if(fn == 'gamma'){
    
    a<-gammaShRaFromModeSD(par1,par2)$shape
    b<-gammaShRaFromModeSD(par1,par2)$rate
    y<- sapply(x, function(x){return(dgamma(x,a,b))})
    
    title.2<- paste('Gamma(',toString(round(a,2)),',',toString(round(b,2)), ')',sep="")
  }
  if(fn == 'inv_gamma'){
    params<-c(par1,par2)
    
    p<- c(params[2], - (4*params[2] + params[1]^2), (5*params[2] - 2*params[1]^2), -(2*params[2] + params[1]^2))
    p<- as.polynomial(p)
    
    a<- max(Re(solve(p)))
    b<- params[1]*(a +1)
    
    y<- sapply(x, function(x){return(dinvgamma(x,shape = a, scale = b))})
    
    
    title.2<- paste('Inverse-gamma(',toString(round(a,2)),',',toString(round(b,2)), ')',sep="")
  }
  if(fn== 'beta'){
    
    a<-betaABfromModeKappa(par1,par2)$a
    b<-betaABfromModeKappa(par1,par2)$b
    
    y<- sapply(x, function(x){return(dbeta(x,a,b))})  
    
    title.2<- paste('Beta(',toString(round(a,2)),',',toString(round(b,2)), ')',sep="")
  }
  if(fn == 'unif'){
    
    y<- sapply(x, function(x){return(dunif(x,par1,par2))}) 
    
    title.2<- paste('Uniform(',toString(round(par1,2)),',',toString(round(par2,2)), ')',sep="")
  }
  if(fn == 'exp'){
    
    y<- sapply(x, function(x){return(dexp(x,par1))}) 
    
    title.2<- paste('Exponential(',toString(round(par1,2)), ')',sep="")
  }
  prior.plot<- data.frame(x=x,y=y,title= rep(title,length(x)),distribution=rep(title.2,length(x)))
  return(prior.plot)
}



graph.prior.multi<-function(plot.data){
  title<-plot.data$title[1]
  
  p<- 
    ggplot(plot.data)+
    geom_line(aes(x=x, y =y,col=distribution))+
    ggtitle(title)+
    labs(y= 'Probability Density', x = 'Parameter')+
    scale_size(range=c(5,20))+
    ylim(c(0, (max(plot.data$y)*2)))+
    theme_minimal()+
    theme(legend.justification=c(.7,.7), legend.position=c(.9,.8), 
          legend.background = element_rect(fill = 'white', colour = 'black', size = .5, linetype = NULL, color = NULL),
          legend.key.size = unit(0.025,'npc'),
          legend.text = element_text(size=7),
          legend.title = element_text(size = 8))
  
  p<-ggplotGrob(p)  
  return(p)
}


visualize.priors.multi<-function(list){
  n.priors<-length(list)
  prior<-list()
  
  
  if(n.priors != 1){
    
    for(i in 1:n.priors){
      
      pr<-read_json(list[[i]])
      
      
      prior[[i]]<-extract.prior(pr)
    }
    
    n.params<-length(prior[[1]])
    
    from<-from.to(list,n.params)$from
    to<-from.to(list,n.params)$to
    
    
    
    p<-list()
    plot<-list()
    
    
    for(i in 1:n.params){
      plot.data<-numeric()
      
      
      for(j in 1:n.priors){
        
        pr<-prior[[j]][[i]]
        plot[[i]]<- plot.prior(pr,min(from[i]),max(to[i]))
        
        plot.data<-rbind(plot.data,plot[[i]])
      }
      p[[i]]<-graph.prior.multi(plot.data)
    }
  }
  
  else{
    
    
    pr<-read_json(list[[1]])
    prior<-extract.prior(pr)
    n.params<-length(prior)
    
    
    from<-from.to(list,n.params)$from
    to<-from.to(list,n.params)$to
    
    
    
    p<-list()
    plot<-list()
    
    for(i in 1:n.params){
      
      plot[[i]]<-plot.prior(prior[[i]], from[i],to[i])
      
      p[[i]]<-graph.prior.multi(plot[[i]])
    }
  }
  return(p)
}
